# 复制证明和时空证明

- 复制证明（Proof-of-Replication，PoRep）：存储证明PoS的一个实际方案，用以证明数据被矿工独立地保存，可以防止女巫攻击、外源攻击和生成攻击。

- 时空证明（Proof-of-Spacetime，PoSt）：证明在一段时间内，矿工在自己的存储设备上实际存储了特定的数据。


## 1. 复制证明（PoRep）
如果某一矿工对网络宣称他保存了一份数据的n份备份，实际上该矿工通过创建多个节点（女巫攻击）的方式或者通过多个矿工共享数据（外源攻击）的方式，实际上只保存了该数据的一份备份。当检验者检验的时候，该矿工使用一份备份完成所有检验，即可达到攻击的行为。该种攻击方式称为女巫攻击。对于存数据的用户来说，原本花钱购买的多分冗余就不存在了。而对于恶意矿工来讲，使用一份存储空间获取了n份数据的收益。这是不允许发生的。复制证明必须有能力防止此类攻击。

那么，复制证明是如何做到的呢？复制证明使用了一种**特殊的加密算法**。该算法理想情况下需要满足一定的要求：

- 加密时间长，解密时间短；
- 生成存储证明复杂度低。


1. 解密时间短指的是提取这些文件时，不会造成过大的计算资源开销，否则会对矿机的配置提出更高的要求。
加密时间长指的是在挑战期间，恶意矿工不能及时通过临时生成加密后的文件来完成挑战。生成证明要求证明者使用加密后的文件作为输入，只有矿工实际存储了加密后的文件，才能保证按时完成挑战。使用满足要求的算法，即便该矿工拥有大量计算资源，也没有足够时间（完成挑战所需最低时间）生成存储证明。

2. 每间隔一段时间，矿工需要提交一次存储证明。考虑到每个阶段提交证明较多，因此通过加密后的文件生成存储证明应该尽量简单快速。因为，加密过程需要的时间必须足够的长，并且尽量不能并行化（可并行化的加密算法可能让攻击者使用高性能计算机或改进计算架构来近似线性地降低执行时间），才能保证恶意矿工无法通过女巫攻击或外源攻击达到目的。
这一加密方法的设计，目前是学术界研究的问题之一，它叫作可验证时延加密算法。目前这一过程通过BLS12-381加密算法（一种Zcash中所使用的新型zk-SNARK椭圆曲线加密算法），多次迭代完成。

### PoRep实现
PoRep协议一共包括3个部分：创建备份Setup，生成存储证明Prove，验证存储证明Verify。创建备份操作在文件初次存储时执行。

- 创建备份  
Setup函数通过给定密封密钥和原数据，生成数据副本和证明。
具体过程如下：
1. 计算出原文件的hash
2. 根据矿工提供的密钥、原数据计算出唯一的副本。这个副本是唯一的，一旦生成以后，副本将按照合约一直保存。这一过程是通过调用封装函数Seal（也就是上面加粗的特殊的加密算法）实现的。
3. 矿工需要证明自己已经完成了封装操作。将原文件、原文件的摘要和副本的摘要，连同密封密钥打包起来，生成证明文件。证明文件会提交到DSN的配置表中，等待其他节点验证，由此完整创建备份操作。

- 存储证明  
Prove算法生成副本的存储证明。当验证者发送挑战c，并指明其验证的目标数据Rc，证明者需要在特定的时间内提交存储证明，证明自己在当前依然存储了副本Rc。PoRep的要求是：生成一条通往rt的默克尔路径作为PoRep证明。输入为副本R，随机挑战c，证明者密钥pk，输出为πPoS。其实现方式如下：首先，生成副本R的默克尔树；找到从rt到Rc的一条默克尔路径；然后将挑战对应的文件、证明者密钥及默克尔路径封装为一个整体，并对它生成存储证明πPoS。

## 2. 时空证明（PoSt）
如何能证明，数据被合理存储，而不是接受复制证明挑战完之后就被丢弃？一个很直接的解决方案是多次挑战多次验证。

PoRep是时间点证明，证明了该时刻存储矿工存储了该文件。PoSt是时间区间证明，证明该时间段内存储矿工实际存储了该文件。

PoSt的设计思路是，使用一种策略，每间隔一定的区块高度，或随机选择检查时间点，向存储矿工挑战。每一次挑战，矿工都需要生成一段PoRep。

### 零知识证明
在PoSt和PoRep可验证时延加密中，需要用到零知识证明zk-SNARK（Zero-Knowledge Succinct Non-interactive ARguments of Knowledge，简洁、非交互式的零知识证明），它指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者在某个概率下相信某个论断依照大概率是正确的。
一些匿名数字货币，例如ZCASH，就使用零知识证明保证交易双方的身份和交易金额匿名。

在PoRep下，我们需要验证完整文件是否被保存，但是显然，每次执行PoRep时，我们不能直接请求完整的文件，这对于网络是极大的资源浪费。